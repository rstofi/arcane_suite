"""The command line tool used in the Snakemake rules: `rename_otf_pointing`,
`apply_phase_rotation` and `list_new_otf_field_names`
"""

import sys
import os
import argparse
import numpy as np
import datetime
import logging

from astropy.coordinates import SkyCoord
from astropy import units as u

from arcane_utils import pipeline
from arcane_utils import ms_wrapper
from arcane_utils.globals import *

from arcane_pipelines.otfms import otfms_pipeline_util as putil
from arcane_pipelines.otfms import otfms_defaults

# === Set logging
#logger = pipeline.init_logger()

# NOTE: for this app the log handler type depends on the input parameters!

# === Functions ===


def save_names_only(yaml_path, output_fname) -> None:
    """Wrapper function for the secondary purpose of the tool: generating the names

    Basically a for loop to get the name for every ID from the yaml file

    Parameters
    ----------
    yaml_path: str
        Path to the Snakemake yaml config file

    output_fname: str
        Path to the file in which the IDs and Names are saved

    Returns
    -------
    Creates a file with the OTF IDs and names

    """
    # Get al the ID's from the config file
    otf_field_ID_mapping = pipeline.get_var_from_yaml(
        yaml_path=yaml_path, var_name='otf_field_ID_mapping')

    otf_acronym = str(pipeline.get_var_from_yaml(yaml_path=yaml_path,
                                                 var_name='OTF_acronym'))

    with open(output_fname, 'w') as namelistf:

        namelistf.write('#List of [OTF IDs, field name, RA (deg), Dec (deg)] generated by arcane-suite at {0:s}\n'.format(
            str(datetime.datetime.now())))

        for ID in otf_field_ID_mapping.keys():

            time_centre, ra_centre, dec_centre = putil.get_closest_pointing_from_yaml(
                yaml_path, ID)

            otf_field_name = putil.generate_OTF_names_from_ra_dec(
                ra=ra_centre, dec=dec_centre, acronym=otf_acronym)

            namelistf.write('{0:s} {1:s} {2:.8f} {3:.8f}\n'.format(
                            ID, otf_field_name, ra_centre, dec_centre))

    return 0

# =========================================
# THIS IS THE PATCH
# =========================================

# Ideally, I should store the (alt, az) coordinates in the config file (i.e. compute
# it during generation in the init step). Then I only need to apply the rotation
# on a per-pointing basis. However, now I am computing it every time from scratch
# so I have all code here in this patch


# NOTE: I am making the patch to work only with a single target field!

def get_altaz_from_icrs(obs_time:float, obs_ra:float, obs_dec:float,
                        obs_location=_MeerKAT_location) -> tuple:
    """
    Input time is an UNIX timestamp (float)
    Input RA, Dec coordinates are in degrees (float)

    Returns the (alt, az) coordinates for the telescope (MeerKAT by default), at
    the given time pointing at (RA, Dec)
    """

    obs_time_in_iso = Time(obs_time, format='unix').format('iso')

    altaz_frame = AltAz(location=obs_location, obstime=obs_time_in_iso)

    sky_coord = SkyCoord(obs_ra * u.deg, obs_dec * u.deg, frame='icrs').transform_to(altaz_frame)

    return (obs_time, sky_coord.alt.deg, sky_coord.az.deg)


def get_init_delay_centre_values(yaml_path: str) -> tuple:
    """
    Helper function to get the delay centre values at the beginning of the observation
    in the icrs reference frame.

    Returns a tuple of (time:float, ra:float, dec:float)

    The time is in UNIX time format, the (ra,dec) values are in degrees
    """

    # Get the MS file from the yaml

    # Get the target field from the yaml

    # Get the reference RA, DEC coordinates from the phase centre


    # Get the RA, Dec and time (!) values from the reference .npz file


    # Get the time matching closest to the (RA, Dec) coordinates of the phase centre
    # NOTE: this time might well be before the observation starts (i.e. we have visibility values)
    # -> this crucial time info is in the .npz file and NOT in the MS!


    # Convert (RA, Dec) to (alt, az) using the observation start time we just obtained
    # -> call get_altaz_from_icrs()

    # Return results


def sidereal_correction(obs_time:float, obs_init_alt:float, obs_init_az:float,
                        obs_location=_MeerKAT_location) -> tuple:
    """The initial MS file has the (RA, Dec) coordinates for the centre of the scan
    in the beginning of the scan. But the correlator is fixed in (alt, az) coordinates.

    And so we need to update the correlator's delay centre as the sky rotates (with
    sidereal speed, hence the function name).

    In this function we compute the new (RA, Dec) coordinates only.
    """

    iso_obs_time = Time(obs_time, format='unix').format('iso')

    # Set the position to (the fixed) (alt, az) position at obs_time
    init_delay_centre = SkyCoord(alt = obs_init_alt * u.deg,
                            az = obs_init_az * u.deg,
                            obstime = iso_obs_time,
                            frame = 'altaz',
                            location = obs_location)

    # Convert back to icrs
    corrected_delay_centre = init_delay_centre.transform_to('icrs')

    return (corrected_delay_centre.ra.deg, corrected_delay_centre.dec.deg)


def apply_sidereal_correction(yaml_path: str,
                obs_start_time:float, obs_start_alt: float, obs_start_az:float,
                yaml_path:str, otf_id:int) -> None:
    """We apply the sidereal correction to the OTF pointing MS.
    """

    # Get the initial (alt, az) values
    # -> call get_init_delay_centre_values()
    # NOTE: this is the redundant calculation part

    # Get the time for the OTF pointing based on ID


    # Compute the new (RA, Dec) coordinates from the sidereal rotation
    # NOTE: here we use the fact that the (alt, az) values set in the correlator
    # are CONSTANT for the scanning part of the observation
    # -> call sidereal_correction()

    # Overwrite the MS pointing centre (probably need to have the field name)


    #DONE




# =========================================

def main():
    """A custom tool with four purposes:

        1. Rename the field (and the corresponding source and pointing) for a given OTF pointing
        2. Create a file with all OTF IDs and the associated names
        3. Output a string that is readable by `chagcentre`
        4. Check if the renamed field position is "close to" the naming position

    As such, this tool is used in *three* rules in the pipeline. For once, it is called
    for every OTF pointing to rename the pointing before rotation and merging.
    Then, it is called to generate the new pointing string that is passed to `chgcentre`
    to perform the rotation. Finally, to generate thie file listing all new names.

    It is most logical to have a single tool that can be used for renaming and
    generating the input for the OTF rotation as both is based on the coordinates
    of the closest pointing from the reference pointing.

    NOTE: this is a standalone tool, that could be useful in general for renaming
        a single field in an MS

    TO DO: add an argument, that allows to specify the new name acroym part

    TO DO: allow to rename not only the first row, by adding an argument for the
        row to rename

    NOTE: The keyword argument descriptions were created by ChatGPT3.

    Keyword Arguments
    -----------------
    '-c' or '--config_file': (required, str)
        Snakemake yaml configuration file for the otfms pipeline

    '-i' or '--otf_id': (optional, str, default: None)
        The ID of the OTF pointing used

    '-sn' or '--save_names_only': (optional, bool)
        If True a file is generated with all OTF IDs and field names

    '-o' or '--output_fname': (optional, str, default: None)
        The output file name in which all the OTF field names being saved

    '-ds' or '--direction_string': (optional, bool)
        If True a direction string is outputted in a format readable by *chgcentre*

    '-l' or '--log_file': (optional, str, default: None)
        The output log file name, only considered when the -ds argument is set

    '-sdc' or '--skip_direction_check': (optional, bool)
        If given, the code checks if the MS phase centre and the direction from
        the name are 'close enough' based on the config.yaml

    """
    # === Set arguments
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-c',
        '--config_file',
        required=True,
        help='Snakemake yaml configuration file for the otfms pipeline',
        action='store',
        type=str)

    parser.add_argument(
        '-i',
        '--otf_id',
        required=False,
        help='The ID of the OTF pointing used',
        action='store', type=str, default=None)

    parser.add_argument(
        '-sn',
        '--save_names_only',
        required=False,
        help='If True a file is generated with all OTF IDs and field names',
        action='store_true')

    parser.add_argument(
        '-o',
        '--output_fname',
        required=False,
        help='The output file name in which all the OTF field names being saved',
        action='store',
        type=str,
        default=None)

    parser.add_argument(
        '-ds',
        '--direction_string',
        required=False,
        help='If True a direction string is outputted in a format readable by *chgcentre*',
        action='store_true')

    parser.add_argument(
        '-l',
        '--log_file',
        required=False,
        help='The output log file name, only considered when the -ds argument is set',
        action='store',
        type=str,
        default=None)

    parser.add_argument(
        '-sdc',
        '--skip_direction_check',
        required=False,
        help="If given, the code checks if the MS phase centre and the direction from the name are 'close enough' based on the config.yaml",
        action='store_true')

    # ===========================================================================
    args = parser.parse_args()  # Get the arguments

    # Get parameters from the config.yaml file
    yaml_path = args.config_file

    # Set the log level (we know that it is in the right format)
    log_level = pipeline.get_var_from_yaml(yaml_path=yaml_path,
                                           var_name='log_level')

    # Run when only the names are generated
    if args.save_names_only:
        logger = pipeline.init_logger()

        logger.info("Running *otfms_otf_pointing_correction* in 'listing' mode")

        if log_level != 'INFO':
            logger.info(
                "Updating logger level to '{0:s}' based on config file...".format(log_level))

            # Update the log level
            new_log_level = logging.getLevelName(log_level)

            logger.setLevel(new_log_level)

        if args.output_fname is None:
            raise ValueError('No output file name is provided!')

        save_names_only(yaml_path=yaml_path, output_fname=args.output_fname)

        sys.exit(0)

    # Check if an ID is provided when working with a single data set
    if args.otf_id is None:
        raise ValueError('No OTF ID is provided!')

    if args.direction_string:
        if args.log_file:
            logger = pipeline.init_logger(log_file=args.log_file)

        else:
            # Set the logger to use the NULL handler, but in the code I still have
            # log messages for debugging
            logger = pipeline.init_logger(null_logger=True)

        logger.info("Running *otf_pointing_correction* in 'chgcentre' " +
                    "mode with OTF_ID: {0:s}".format(args.otf_id))
    else:
        logger = pipeline.init_logger()
        logger.info("Running *otf_pointing_correction* in 'renaming' " +
                    "mode with OTF_ID: {0:s}".format(args.otf_id))

    if log_level != 'INFO':
        logger.info(
            "Updating logger level to '{0:s}' based on config file...".format(log_level))

        # Update the log level
        new_log_level = logging.getLevelName(log_level)

        logger.setLevel(new_log_level)

        del new_log_level

    # Check if OTF directories exists or not
    output_otf_dir = pipeline.get_var_from_yaml(yaml_path=yaml_path,
                                                var_name='blob_dir')

    # Compute the OTF pointing MS name based on the naming convention
    otf_MS_path = os.path.join(
        output_otf_dir,
        'otf_pointing_no_{0:s}.ms'.format(
            args.otf_id))

    if os.path.isdir(otf_MS_path) == False:
        raise FileNotFoundError(
            'Single pointing OTF format MS not found as: {0:s}'.format(otf_MS_path))

    time_centre, ra_centre, dec_centre = putil.get_closest_pointing_from_yaml(
        yaml_path, args.otf_id)

    if args.direction_string:
        # Get the pointing centre string
        pointing_string = putil.generate_position_string_for_chgcentre(
            ra=ra_centre, dec=dec_centre)

        logger.info(
            'Coordinate string for chgcentre: {0:s}'.format(pointing_string))

        # Print would also work, but it adds \n automatically...
        sys.stdout.write(pointing_string)

        sys.exit(0)

    else:
        logger.info('Renaming field in {0:s}'.format(otf_MS_path))

        otf_acronym = str(pipeline.get_var_from_yaml(yaml_path=yaml_path,
                                                     var_name='OTF_acronym'))

        logger.info("Using the acronym '{0:s}'".format(otf_acronym))

        # Now compute the name form the RA and Dec values
        otf_field_name = putil.generate_OTF_names_from_ra_dec(
            ra=ra_centre, dec=dec_centre, acronym=otf_acronym)

        logger.info('The new field name, based on the coordinates is: {0:s}'.format(
            otf_field_name))

        # Now renaming the field
        otf_MS = ms_wrapper.create_MS_table_object(otf_MS_path)

        # Check if the new field name, is "close to" the actual phase centre in
        # the MS
        if not args.skip_direction_check:
            dir_tol = float(
                pipeline.get_var_from_yaml(
                    yaml_path=yaml_path,
                    var_name='position_crossmatch_threshold'))

            logger.info(
                "Checking the MS phase centre position against the renaming \
position with {0:.4f} deg direction tolerance".format(dir_tol))

            # Hnadle numerics, and if threshold is set to 0
            if dir_tol == 0.:
                logger.warning(
                    "The direction separation tolerance is set to 0!")

                dir_tol = 1e-7  # To handle numerics

            phase_centres_field_IDs_dict = ms_wrapper.get_phase_centres_and_field_ID_list_dict_from_MS(
                otf_MS, field_ID_list=[0], close=False)

            phase_centre_coord = SkyCoord(
                phase_centres_field_IDs_dict[0][0] * u.deg,
                phase_centres_field_IDs_dict[0][1] * u.deg,
                frame='icrs')  # Since only J2000 is supported currently

            logger.debug(
                "The phase centre coordinates: {0:s}".format(
                    putil.generate_position_string_for_chgcentre(
                        ra=phase_centre_coord.ra.deg,
                        dec=phase_centre_coord.dec.deg)))

            nominal_coords = SkyCoord(ra_centre * u.deg, dec_centre * u.deg,
                                      frame='icrs')

            logger.debug(
                "The nominal coordinates from name: {0:s}".format(
                    putil.generate_position_string_for_chgcentre(
                        ra=nominal_coords.ra.deg,
                        dec=nominal_coords.dec.deg)))

            # Compute separation in degrees
            sep = float(phase_centre_coord.separation(nominal_coords).deg)

            if sep > dir_tol:
                raise ValueError(
                    "The separation of MS phase centre and name coordinates are over the matching threshold!")

        ms_wrapper.rename_single_field(mspath=otf_MS,
                                       field_ID=0,
                                       new_field_name=otf_field_name,
                                       source=True,
                                       pointing=True,
                                       close=True)

        logger.info('Exit 0')

        sys.exit(0)


# === MAIN ===
if __name__ == "__main__":
    main()
