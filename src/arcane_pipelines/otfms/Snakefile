"""Sankefile for the otfms pipeline. Each rule calls a custom command-line application
with the name `otfms_rule_name_in_this_snakefile`

Some rules are only a simple wrapper around casa tasks, but some are doing more
than calling task from some library.

For more info on the individual rules, see the correspondig python scripts!

The otfms pipleine builds the following file structure:

    working_dir/
    |
    -- snakefile #This file, created at pipeline initialisation
    |
    -- config.yaml #Created at pipeline initialisation
    |
    -- logs/
    |   |
    |    -- log files from all rules
    |
    -- results/
    |   |
    |   -- final.ms #The OTF format MS
    |   |
    |   -- calibrators.ms #The claibrators
    |   |
    |   -- otf_field_names.dat #The OTF ID's and the corresponding names
    |   |
    |   -- otf_pointings/ #All the single OTF pointings
    |       |
    |       -- otf_pointing_no_0.ms
    |       |
    |       ...
    |       |
    |       -- otf_pointing_no_N.ms
    |
    -- .snakemake/ #Hidden directory created by snakemake for pipeline handling

NOTE: this pipeline requires double (!) the input MS size

To visualise the pipeline logic run the following command under the working directory:

    snakemake --rulegraph | dot -Tpdf > otfms_rule_graph.pdf

"""
import os
import numpy as np

#=== Configuration ===
configfile: "config.yaml"

#Getting values from the config file
workdir: config['working_dir']

WORKING_dir = config['working_dir'] #Don't need this explicitly
MS_dir = config['MS']
POINTING_REF_file = config['pointing_ref']
LOG_dir = config['log_dir']
OUTPUT_dir = config['output_dir']
OTF_OUTPUT_dir = config['output_otf_dir']
YAML_path = os.path.join(WORKING_dir, 'config.yaml')

#The field_ID_mapping is an ID to UNIX timestamp mapping
#We use only the keys in the Snakefile, but in the actual rules the configfile is
#used based on the ID's basically

OTF_FIELD_ID_MAPPING = config['otf_field_ID_mapping']

#To avoid ambiguity in wildcards, use the keys only
OTF_FIELD_IDs = list(OTF_FIELD_ID_MAPPING.keys())

#=== Rules ===
rule all:
    input:
        '{0:s}/otf_field_names.dat'.format(WORKING_dir),
        '{0:s}/final.ms'.format(OUTPUT_dir)

#Split the calibrator field(s) from input MS
rule split_calibrators:
    input:
        '{0:s}'.format(MS_dir)
    output:
        directory('{0:s}/calibrators.ms'.format(OUTPUT_dir))
    log:
        '{0:s}/split_calibrators.log'.format(LOG_dir)
    params:
        output_dir = OUTPUT_dir,
        log_dir = LOG_dir
    shell:
        'mkdir {params.output_dir}/calibrators.ms && touch {params.log_dir}/split_calibrators.log'

#List the new OTF pointing names
rule list_new_otf_field_names:
    input:
        '{0:s}'.format(YAML_path)
    output:
        '{0:s}/otf_field_names.dat'.format(WORKING_dir)
    log:
        '{0:s}'.format(LOG_dir) +\
        '/list_new_otf_field_names.log'
    params:
        log_dir = LOG_dir,
        yaml_path = YAML_path,
        output_fname = '{0:s}/otf_field_names.dat'.format(WORKING_dir)
    shell:
        'otfms_otf_pointing_correction -c {params.yaml_path} -sn -o {params.output_fname} ' +\
        '> {params.log_dir}/list_new_otf_field_names.log'

#Split a single OTF pointing from the MS
rule split_otf_scans_by_pointing:
    input:
        '{0:s}'.format(MS_dir),
        '{0:s}'.format(POINTING_REF_file)
    output:
        directory('{0:s}'.format(OTF_OUTPUT_dir) +\
                '/otf_pointing_no_{field_ID}.ms')
    log:
        '{0:s}'.format(LOG_dir) +\
        '/otf_pointing_no_{field_ID}_split.log'
    params:
        output_otf_dir = OTF_OUTPUT_dir,
        log_dir = LOG_dir,
        yaml_path = YAML_path,
        casa_executable = os.path.join(OTF_OUTPUT_dir, 'split_otf_pointing_no_{field_ID}.py')
    shell:
        'otfms_split_otf_scans_by_pointing -c {params.yaml_path} -i {wildcards.field_ID} ' +\
        '> {params.log_dir}/otf_pointing_no_{wildcards.field_ID}_split.log ; ' +\
        'casa --log2term --nogui --nologfile --nocrashreport -c {params.casa_executable} ' +\
        '>> {params.log_dir}/otf_pointing_no_{wildcards.field_ID}_split.log 2>&1 ; ' +\
        'otfms_split_otf_scans_by_pointing -p -c {params.yaml_path} -i {wildcards.field_ID} ' +\
        '>> {params.log_dir}/otf_pointing_no_{wildcards.field_ID}_split.log '

#Rename the pointing field so later imaging processes can access it as a separate field
#IAU specifications: http://cdsweb.u-strasbg.fr/Dic/iau-spec.html
rule rename_otf_pointing:
    input:
        '{0:s}'.format(OTF_OUTPUT_dir) +\
        '/otf_pointing_no_{field_ID}.ms',
        '{0:s}'.format(LOG_dir) +\
        '/otf_pointing_no_{field_ID}_split.log'
    output:
        #Leave empty as snakemake overwrite directories
    log:
        '{0:s}'.format(LOG_dir) +\
        '/otf_pointing_no_{field_ID}_renaming.log'
    params:
        output_otf_dir = OTF_OUTPUT_dir,
        log_dir = LOG_dir,
        yaml_path = YAML_path
    shell:
        'otfms_otf_pointing_correction -c {params.yaml_path} -i {wildcards.field_ID} ' +\
        '> {params.log_dir}/otf_pointing_no_{wildcards.field_ID}_renaming.log'

#Apply the phase rotation on the single pointing
rule apply_phase_rotation:
    input:
        '{0:s}'.format(LOG_dir) +\
        '/otf_pointing_no_{field_ID}_renaming.log'
    output:
        #Leave empty as snakemake overwrite directories
    params:
        output_otf_dir = OTF_OUTPUT_dir,
        log_dir = LOG_dir,
        yaml_path = YAML_path
    log:
        '{0:s}'.format(LOG_dir) +\
        '/otf_pointing_no_{field_ID}_chgcentre.log'
    shell:
        'chgcentre {params.output_otf_dir}/otf_pointing_no_{wildcards.field_ID}.ms ' +\
        '$(otfms_otf_pointing_correction -c {params.yaml_path} -i {wildcards.field_ID} ' +\
        '-ds -l {params.log_dir}/otf_pointing_no_{wildcards.field_ID}_chgcentre.log) ' +\
        '>> {params.log_dir}/otf_pointing_no_{wildcards.field_ID}_chgcentre.log 2>&1'
        #'touch {params.log_dir}/otf_pointing_no_{wildcards.field_ID}_chgcentre.log'

#Merge phase-rotated OTF pointings and the calibrator(s) 
rule merge_scan_and_target:
    input:
        expand('{0:s}'.format(LOG_dir) +\
        '/otf_pointing_no_{field_ID}_chgcentre.log', field_ID=OTF_FIELD_IDs),
        expand('{0:s}'.format(OTF_OUTPUT_dir) +\
        '/otf_pointing_no_{field_ID}.ms', field_ID=OTF_FIELD_IDs),
        '{0:1}/calibrators.ms'.format(OUTPUT_dir)
    output:
        directory('{0:s}/final.ms'.format(OUTPUT_dir))
    log:
        '{0:s}/merge_scan_and_target.log'.format(LOG_dir)
    params:
        output_dir = OUTPUT_dir
    shell:
        'mkdir {params.output_dir}/final.ms'

#TO DO: add this rule at the end of the pipeline
#Purge all casa leftover files: the .last files

#IDEA => add this functionality to the shell: part of the rule `all`
# so the clean up happens when the pipeline is finished